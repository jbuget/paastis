# 2022-09-06 - R√©flexions techniques

## Gateway vs. proxy vs. tunnel

@VincentHardouin m'a remont√© qu'il n'aime pas le terme "gateway" pour d√©signer la brique qui va faire passe-plat de requ√™tes HTTP.

Je m'√©tais d√©j√† pos√© la question avant de lui l√¢cher le terme.

J'ai creus√© plusieurs pistes / articles :
- [Serveur Fault](https://serverfault.com/questions/994319/what-is-the-difference-between-a-proxy-server-and-a-gateway-server)
- [Stack Overflow](https://stackoverflow.com/a/34284700/2120773)
- [Akana](https://www.akana.com/blog/api-proxy-vs-api-gateway)

Je n'arrive pas √† trouver de r√©ponse claire, satisfaisante et d√©finitive.
Faute de mieux, je reste sur "gateway".

## Architecture technique

### DNS

Il faut que `app-1.gateway.example.com`, `app-2.gateway.example.com` et `app-n.gateway.example.com` redirige respectivement vers `app-1.scalingo.com`, `app-2.scalingo.com` et `app-n.scalingo.com`.

Mon id√©e est de d√©finir 2 entr√©es `CNAME` : 

```shell
# Zone DNS pour example.com
gateway 10800 IN CNAME paastis-gateway.osc-fr1.scalingo.io.
*.gateway 10800 IN CNAME gateway.example.com.
```

Il faut que le FQDN de l'app "paastis-gateway" soit associ√© c√¥t√© Scalingo au DNS `gateway.example.com`.

Si tout se passe comme je le pense / l'esp√®re, √ßa devrait fonctionner ü§û. 

### Int√©ragir avec Scalingo

Par souci de simplicit√©, je d√©cide de passer par leur client JavaScript.

Scalingo l'a mis √† jour il n'y a pas si longtemps.

Le d√©faut est qu'il ne g√®re pas le multi-r√©gions.
Je suis donc oblig√© de g√©n√©rer 2 clients.
J'en fais des singletons.

> ‚ö†Ô∏è Il faudra g√©rer le cas du refresh de token.

√áa semble plut√¥t bien fonctionner.
Je craignais de me faire ban ou rate limit.
Pour le moment, avec une vingtaine d'apps et malgr√© de nombreux refresh de page, √ßa passe üëç.

### Registre des apps

La solution qui me para√Æt la plus simple (et performante ?) est de conserver √† tout moment un "registre des applications actives". 

Pour √™tre en capacit√© d'avoir une gateway multi-instances, je d√©cide de conserver le registre dans un Redis.

| App name | Last request datetime |
|----------|-----------------------|
| app-1    | 2022-09-06_17:39:09   |
| app-2    | 2022-09-06_17:17:54   |
| app-n    | 2022-09-06_17:23:31   |

Lorsqu'on re√ßoit une requ√™te, on regarde si l'app est dans le registre.

Si "non", alors on r√©veille l'app sur Scalingo et on ajoute une entr√©e dans Redis.

> Je ne suis pas certain qu'il soit n√©cessaire de stocker la date de derni√®re requ√™te.
> Je pense qu'il est possible de d√©finir la dur√©e de vie de r√©tention de l'entr√©e Redis au moment de l'ajout.
> En r√©fl√©chissant mieux, si je suis oblig√©.
> Il ne faudrait pas que Redis vire l'entr√©e et que je perde l'info sans avoir pu √©teindre l'app Scalingo.

Pour le multi-instances, on peut peut-√™tre ajouter une entr√©e particul√®re `last_check` pour que seule la premi√®re instance qui fait le check lance l'auto)pause des apps.

Avec ce genre de m√©canisme, si une application est ajout√©e, le premier qui tente d'y acc√©der ajoutera l'entr√©e.

### R√©veil d'une app

Il faut pr√©voir un m√©canisme qui v√©rifie toutes les 6 secondes (pour faire 6 * 10 = 60s) qu'une app est correctement restart√©e. 

### Cron

Plusieurs pistes possibles : 
- node-cron
- pgboss
- BullMQ

Je pense - et @VincentHardouin est align√© - que dans un premier temps, on peut se contenter d'un simple `node-cron`.

## Impl√©mentation

J'ai cr√©√© une app [hello-fastify](https://github.com/jbuget/hello-fastify) pour tester la gateway.

Micro p√©touille avec le multi-r√©gion Scalingo.
Quant on register un proxy Fastify pour une app, il faut penser √† tenir compte de la r√©gion pour l'upstream.

Je suis emb√™t√© √† cause de la double-r√©gions, qu'il faut aussi g√©rer c√¥t√© DNS. 

J'ai oubli√© de mettre un pre-handler qui r√©cup√®re le sous-domaine et redirige avec pr√©fixe.

Utilisation de [tldts](https://github.com/remusao/tldts) pour extraire le subdomain d'un hostname.

J'ai gal√©r√© toute la soir√©e pour tenter de faire une vieille r√©√©criture d'URL.
√áa ne sent vraiment pas bon.
J'ai l'impression de faire n'importe quoi.
Je trouve tr√®s peu de ressources √† la recherche "fastify change request url on the fly".
C'est le signe qu'il y a un truc louche.

C'est alors que je tombe sur cette page de documentation de Fastify : "[Recommendations](https://www.fastify.io/docs/latest/Guides/Recommendations/)".

> With Node.js, one can write an application that directly handles HTTP requests. As a result, the temptation is to write applications that handle requests for multiple domains, listen on multiple ports (i.e. HTTP and HTTPS), and then expose these applications directly to the Internet to handle requests.
> The Fastify team strongly considers this to be an anti-pattern and extremely bad practice:
> 
> It adds unnecessary complexity to the application by diluting its focus.
> It prevents horizontal scalability.

Bien que je sente que je suis vraiment au bout du bout d'avoir un r√©sultat, je reconsid√®re mon choix technique.
Je me demande si la bonne solution ne serait pas de mettre un NGINX en frontal qui se charge de la r√©√©criture (inversion sous-domaine ‚Üí request URL prefix).
Je ne suis pas tr√®s bon en NGINX, mais √ßa devrait le faire.

Le truc qui m'emb√™te, c'est d'ajouter un √©l√©ment √† la cha√Æne.
En cas de pic de trafic, le risque est de devoir l'inclure dans l'√©quation.
En m√™me temps, si le NGINX est embarqu√© avec la gateway, le scaling horizontal (multiplication des isntances d'apps) sera fait en amont.
Donc √ßa passe.
Testons.

La premi√®re chose √† faire est de reconfigurer le projet Scalingo pour qu'il comprenne qu'on a :
- un NGINX
- une app Node.js
